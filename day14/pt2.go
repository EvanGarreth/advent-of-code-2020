package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type mask struct {
	setOnes  int64
	wildBits []int64
}

// the computer uses 36 bits, so use 64 bit ints to hold the info
type computer struct {
	mask   *mask
	memory map[int64]int64
}

func (m *mask) updateMask(newMask string) {
	// unset all 36 bits, will be OR'd with the value to force ones
	var setOnes int64 = 0
	wildBits := make([]int64, 0)
	for i, bit := range newMask {
		// calculate the number of bits to shift to the left since we interate over the mask from high to low bits
		shift := len(newMask) - i - 1

		switch bit {
		case 'X':
			wildBits = append(wildBits, int64(shift))
		case '1':
			// set the corresponding bit
			setOnes |= 1 << shift
		}
	}
	m.setOnes = setOnes
	m.wildBits = wildBits
}

func (c *computer) setBits(addr int64, val int64) {
	// OR the value to force all 0's to 1's where masked
	maskedAddr := addr | c.mask.setOnes
	c.findAndSetAddr(maskedAddr, val, 0)
}

// Find all addresses generated by the wild card bits, then assign the value to that addrt
func (c *computer) findAndSetAddr(addr int64, val int64, n int) {
	// all wildcard bits have been set, so assign the value to the resulting address
	if n >= len(c.mask.wildBits) {
		c.memory[addr] = val
		return
	}

	bit := c.mask.wildBits[n]
	// use the current address and a copy with the wild bit toggled
	addr1 := addr
	addr0 := addr ^ (1 << bit)
	c.findAndSetAddr(addr1, val, n+1)
	c.findAndSetAddr(addr0, val, n+1)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: go run pt2.go <input_file>")
		os.Exit(1)
	}

	fileName := os.Args[1]
	file, err := os.Open(fileName)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	// since addresses with unchanged values are considered 0, can use a map to hold only the ones that are changed
	memory := make(map[int64]int64, 0)
	mask := &mask{}
	c := &computer{mask, memory}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		if strings.Index(line, "mask") != -1 {
			// the mask always starts at index 7
			index := 7
			c.mask.updateMask(line[index:])
		} else {
			// the starting number for the address is always at index 4, so find the terminating "]" for the end
			right := strings.Index(line, "]")
			addr, _ := strconv.ParseInt(line[4:right], 10, 64)
			// the starting point for the value is always + 2 from the equal sign and runs to the end of the string
			left := strings.Index(line, "=") + 2
			val, _ := strconv.ParseInt(line[left:], 10, 64)

			c.setBits(addr, val)
		}
	}

	var sum int64 = 0
	for _, val := range c.memory {
		sum += val
	}
	fmt.Println("Sum of all set memory values:", sum)
}
